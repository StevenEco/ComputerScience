# 进程管理01

## 进程的概念

进程是计算机中一个非常重要的概念，在整个计算机发展历史中，操作系统中程序运行机制的演变按顺序大致可以分为：

1. 单道程序：通常是指每一次将一个或者一批程序（一个作业）从磁盘加载进内存，CPU必须等待I/O完成后才可以进行执行，CPU利用率低。
2. 多道程序：讲多个作业调入内存后自动处理，但是单道程序和多道程序均无交互性，可控性差
3. 进程：程序+PCB(状态周期描述)
4. 线程

### 单道 --> 多道系统

从单道程序演化为多道程序就是CPU的高速与I/O的低速有着显著矛盾，因此引入了多道程序作为解决。举一个例子，在单道程序中，倘若I/O没有完成，那么CPU就会一直处于空闲状态。但是在多道程序中，当某程序在占用CPU的时候，其余程序可以开始进行I/O请求，互不干扰，这样就减少了在I/O中CPU的空闲。当某个程序释放CPU后，下一程序继续占用CPU。

在多道程序中，经常会有这种情况，例如某程序需要监测输入值，那么，该程序就会委托I/O系统去取值，那么在取值完成前，该程序并不需要占用CPU，那么程序会由于I/O阻塞主动放弃CPU，并且进入执行队列尾部，此时CPU会按出队列的顺序依次分配。

### 多道程序 --> 进程

进程就是在程序中加入一些描述程序状态的块（PCB)，

从多道程序演化为进程的过程中是通过提高**并发性**，从而进一步的提高CPU的利用率。事实上也就是在多道程序死板的调度机制中灵活的进行控制程序运行的顺序等。实现的功能便是PCB的监控。

### 进程 --> 线程

在进程之下，我们引入了线程。在说线程之前，我们引入那么一个问题，假定你制作了一个即时通讯的程序，如果你只是用一个进程去控制程序运行，会发生什么？事实上这里发生的事情你有时候可以在一些小厂商做出的低劣游戏中发现这一问题。我们在有些制作不好、历史久远或者代码质量差的游戏中，经常能发现，一旦网卡了，整个游戏甚至都会卡顿甚至无响应，游戏的渲染也受到了很大的影响。有时候是因为网络一直在尝试发包导致，但是更多时候是因为进程调度问题。可是为什么网络是基于外部的，却可以影响内部的引擎渲染之类的功能呢？原因就是我们之前讲过，请求网络是一个明显的I/O过程，假设网络不好，那么我们的程序一直处于I/O阻塞的状态下，从而放弃CPU，那么我们渲染的代码也会迟迟得不到运行。会到我们之前的问题，假设你只是用一个进程去制作了即时通讯软件，一旦网络丢包之类的网络故障发生时，你的程序很容易卡顿。

说了那么多，我们应该如何去解决这个问题？很自然的我们会想到使用多进程去制作一个软件，那么其中一个进程发生阻塞的时候，我们其余的进程会继续占用CPU，则整体运行并不会受太大影响。但是这种方法需要占用大量的时空，因为进程的调度是依赖PCB以及PCB的监控程序，进程切换过程中，上下文切换也会导致PCB状态切换，需要花费大量的时间进行查询、修改等操作，并且内存栈的使用也会过于频繁导致空间消耗，并且在操作系统中，PCB的数量是有限的，因此使用多进程并不是一个号的方法。

这里我们就引出多线程的方法，**进程就成为了线程的一个容器，且进程和线程可以同时存在**，线程几乎不占用多少空间，整体也比进程小的多，那么对线程的调度开销就会远比进程小得多。进程的数量也减少了，那么整体系统的压力也小了。

