# 堆结构

## 简介

在数据结构中，堆可以理解成一种特殊的树形结构，通常我们把堆看成是一个完全二叉树结构，堆通常用于排序算法中，对于 *Top K* 问题的处理有着极大的作用，举一个简单的问题用于引出我们的堆，例如现在我需要班上前5名的成绩，假定你是老师，你会很自然的在成绩单上一个一个按成绩大小寻找，找到第五名时就停止查找，即使这个成绩单是无序的，这就很明显体现了一个问题，对于*Top K*，我们完全没有必要关系K之后的数据是什么，因此在排序中，巧妙的利用堆可以让你的算法提前终止。堆根据存储规则的不同，我们将堆结构分为大根堆（又称大顶堆）和小根堆（又称小顶堆）。

## 堆的存储规则

对于堆的存储分为两种，对于大根堆，每一个父节点均不小于子节点；对于小根堆，每一个父节点则不大于子节点。同时堆又是一个完全二叉树结构，那么在堆的树中，插入数据默认均为从左往右的顺序进行插入。不过通常而言，我们并不会真的构建一个完全二叉树进行存储堆的内容，因为完全二叉树的特性，我们可以很轻易的将数组看成一个堆，这里我们可以轻松的定义

对于任意的数组array[]，我们将其看成是一颗完全二叉树层序遍历的序列，那么定义：

1. 节点array[i] 的父节点为*i==0 ? null : array[i-1/2]*
2. 节点array[i]的左孩子为，*array[2*i + 1]*
3. 节点array[i]的右孩子为，*array[2*i + 2]*

这样我们的数组就可以当成一个完全二叉树看待了，那么再考虑堆的定义：

假定前提0 <= i < (n-1)/2

1. 满足*array[i] <= array[2i + 1]* 且 *array[i] <= array[2i + 2]* 为小根堆。
2. 满足*array[i] >= array[2i + 1]* 且 *array[i] >= array[2i + 2]* 为大根堆。

这样我们就可以称我们的数组为一个堆了，不过通常而言，并没有太多数组符合这个条件，因此我们接下来就需要堆化我们的数组

## 堆化数组

堆化数组的意思就是将一个普通的数组将其变成一个符合堆结构的数组，这样就可以将数组看成堆了，这个过程就被成为堆化数组。

### 大小根堆的堆化

这里将详细的阐述如何将一个杂乱无章的数组变成一个对应的大小根堆。这里我们直接采用的是C#代码，利用拓展方法的手段进行实现。

为了方便起见，我们先实现一个Swap方法：

``` C#
private static void Swap(int[] array, int i, int j)
{
    int temp = array[i];
    array[i] = array[j];
    array[j] = temp;
}
```

对于一个堆，根据定义我们画出一颗对应的完全二叉树，如下图所示：

可以发现这个二叉树并不符合我们堆的定义，我们从最底层往上进行修改，这其实有点类似机器学习中的 *反向梯度传播(BP)* 算法，从后往前传递值的好处就是可以规避掉不少重复计算。我们以最底层的**非叶节点**开始进行堆的调整，这里我们姑且把这个操作叫 ***Heapify*** ,再底层做完Heapify操作后，向上走一层，继续我们的操作直至到根节点。这样一个符合规则的堆就出现了。过程如下图所示:

并且可以发现我们需要调整的
代码如下：

``` C#
// i是需要调整的根节点，n是数组大小，至于为什么放n再此处，后面会进行解释
private static void Heapify(int[] array, int i, int n = -1)
{
    if (n == -1)
    {
        n = array.Length;
    }
    int lChild = 2 * i;
    int rChild = 2 * i + 1;
    int maxIndex = i;
    // 节点存在且大于目前的根节点
    if (lChild < n && array[lChild] > array[maxIndex])
    {
        maxIndex = lChild;
    }
    if (rChild < n && array[rChild] > array[maxIndex])
    {
        maxIndex = rChild;
    }
    // 如果父节点不是最大节点
    if (maxIndex != i)
    {
        Swap(array, i, maxIndex);
        // 此时根节点的值已经被换成了maxIndex的值
        Heapify(array, maxIndex, n);
    }
}

public static void BuildHeap(this int[] array)
{
    // 从最后一个叶子节点的父节点开始进行调整
    int parent = (array.Length - 2) / 2;
    // 父节点是连续的
    for (int i = parent; i >= 0; i--)
    {
        Heapify(array, i);
    }
}

```

通过这个算法，我们可以轻松的建立起一个大根堆，那么这里留下一个小问题，读者可以尝试实现小根堆的算法，事实上只需要再上述算法中进行一丝丝的修改即可完成小根堆的构建，此处不再赘述。

## 堆排序

一直在说堆的结构以及Top K问题，在前文中你很难发现大、小根堆有什么特别之处，只是一颗构造奇特的树罢了。但是事实上堆一旦被构建，则完全不需要对整个数组排序后才能指导前N小的数（前N大），只需要控制遍历的次数就可以。

思考下面这个过程，将堆中每个节点做上下标，将根节点和最后一个叶子节点进行一次交换，并且取出最后一个叶子节点，再对整个堆进行Heapify操作，重复至堆中没有元素，那么你取出的数就已经变成了一个有序的序列了。这就是大名鼎鼎的堆排序算法。

对于普通的算法，需要取得前5大的数字，需要使用部分排序或者整体排序，算法复杂度并不低，而堆排序却可以通过这种看起来简单的办法进行排序。

我们这里可以通过控制Heapify所遍历的总节点数进行删除最后一个叶子节点的操作，并且非常容易实现。

``` C#
public static void HeapSort(this int[] array, int n = -1)
{
    if (n == -1)
    {
        n = array.Length - 1;
    }
    else
    {
        n = array.Length - n - 1;
    }
    BuildHeap(array);
    for (int i = n; i >= 0; i--)
    {
        Swap(array, i, 0);
        // 这样就遍历不到以及处理过的叶子节点
        Heapify(array, 0, i);
    }
}
```

## 思考Top K问题

Top K问题总是一个海量的数据中需要一个很小的排列数据。因此如果将数据都进堆显然是不合适的，通常我们只会维护一个大小为K的堆，先用前k个元素生成一个小顶堆，这个小顶堆用于存储，当前最大的k个元素。接着，从第k+1个元素开始扫描，和堆顶（堆中最小的元素）比较，如果被扫描的元素大于堆顶，则替换堆顶的元素，并调整堆，以保证堆内的k个元素，总是当前最大的k个元素。直到，扫描完所有n-k个元素，最终堆中的k个元素，就是我们需要求的TopK。

这个内容留给读者进行思考，算法并不复杂。